#!/usr/bin/env perl

# ABSTRACT: Process supervision shell for Perp and S6

use lib 'lib';
use warnings;
use strict;

use Carp;
use Getopt::Compact;
use Term::ANSIColor qw/:constants/;
use Term::ShellUI;
use Try::Tiny;

my $go = Getopt::Compact->new(
	name => 'svsh',
	modes => ['perp', 's6'],
	struct => [
		[['d', 'basedir'], 'service directory (directory on which the supervisor was started)', '=s'],
		[['b', 'bindir'], 'directory where the supervisor is installed (e.g. /usr/sbin)', ':s']
	]
);
my $opts = $go->opts;

my $class = 'Svsh::' . ( delete $opts->{perp} ? 'Perp' :
				 delete $opts->{s6}   ? 'S6'   :
				 confess 'What supervisor are you using?' );

eval "require $class";

confess $@
	if $@;

_check_basedir($opts->{basedir});

my $svsh = $class->new(%$opts);

my $term = Term::ShellUI->new(
	commands => {
		status => {
			desc => 'Lists all running processes',
			method => sub {
				my $statuses = $svsh->status(@_);
				print BOLD BLACK ON_WHITE
					join(' | ',
						sprintf('%16s', 'process'),
						sprintf('%10s',  'status'),
						sprintf('%8s', 'duration'),
						sprintf('%5s',      'pid')
					), ' ', RESET, "\n";
				foreach (sort keys %$statuses) {
					my $s = $statuses->{$_};
					my $color = $s->{status} eq 'up' ? GREEN :
							$s->{status} eq 'resetting' ? YELLOW : RED;
					print BOLD sprintf('%16s', $_), RESET, ' | ',
						$color, sprintf('%10s', $s->{status}), RESET, ' | ',
						sprintf('%8s', $s->{duration}.'s'), ' | ',
						sprintf('%5s', $s->{pid}), " \n";
				}
				print "\n";
			}
		},
		start => {
			desc => 'Starts process(es)',
			minargs => 1,
			method => sub { print $svsh->start(@_) }
		},
		stop => {
			desc => 'Stops a running process',
			minargs => 1,
			method => sub { print $svsh->stop(@_) }
		},
		restart => {
			desc => 'Stops and start a process or processes',
			minargs => 1,
			method => sub { print $svsh->restart(@_) }
		},
		enable => {
			desc => 'Start a process and enable auto-starting of it',
			minargs => 1,
			method => sub { print $svsh->enable(@_) }
		},
		disable => {
			desc => 'Stops a process and disables auto-starting of it',
			minargs => 1,
			method => sub { print $svsh->disable(@_) }
		},
		signal => {
			desc => 'Sends a signal to a process (or processes)',
			minargs => 1,
			method => sub { print $svsh->signal(@_) }
		},
		rescan => {
			desc => 'Rescans the service directory to look for new/removed services',
			method => sub { print $svsh->rescan }
		},
		update => { alias => 'rescan' },
		fg => {
			desc => 'Move a process to the foreground',
			minargs => 1,
			maxargs => 1,
			method => sub { $svsh->fg(@_) }
		},
		terminate => {
			desc => 'Shut down the process supervisor (all processes will terminate)',
			method => sub { $svsh->terminate(); shift->process_a_cmd('quit'); }
		},
		shutdown => { alias => 'terminate' },
		quit => {
			desc => 'Quit this program',
			maxargs => 0,
			method => sub { shift->exit_requested(1) }
		},
		exit => { alias => 'quit' }
	},
	prompt => 'svsh> '
);
$term->process_a_cmd('status')
	unless scalar @ARGV;
$term->run(@ARGV);

sub _check_basedir {
	my $basedir = shift;
	try {
		$basedir || die "Base directory not provided";
		-e $basedir && -d $basedir
			|| die "Base directory does not exist or is not a directory";

		return $basedir;
	} catch {
		print "ERROR: $_\n", $go->usage;
		exit 1;
	};
}
