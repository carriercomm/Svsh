#!/usr/bin/env perl

BEGIN {
	binmode STDOUT, ':encoding(utf8)';
}

# ABSTRACT: Process supervision shell for Perp/S6/Runit

use lib 'lib';
use warnings;
use strict;

use Carp;
use Getopt::Compact;
use Term::ANSIColor qw/:constants/;
use Term::ShellUI;
use Try::Tiny;

=head1 NAME

svsh - Process supervision shell for Perp/S6/Runit

=head1 DESCRIPTION

C<svsh> is a command line shell for process supervision suites of the L<daemontools|http://cr.yp.to/daemontools.html> family. Currently, it supports
L<perp|http://b0llix.net/perp/>, L<s6|http://www.skarnet.org/software/s6/index.html>
and L<runit|http://smarden.org/runit/> (yes, ironically C<daemontools> is not supported
yet). It provides a unified interface allowing easy inspection and manipulation of services
(i.e. processes) managed by supported supervision suites.

C<scsh> does not require any configurations or changes to your suite's service directories;
just point it at a base directory and you immediately get a usable shell, listing all
services and their statuses, and accepting commands to perform on them.

The shell provides a very simple syntax that is easy to remember, far simpler than the
particular syntax of the underlying tools provided by the supervision suite itself. Instead
of having to execute C<perpctl -b /services q nginx> to restart an nginx service running from
C</services/nginx>, just execute C<restart nginx>. Couldn't be simpler.

=begin markdown

![screenshot](https://ido50.github.io/Svsh/screenshot.png)

=end markdown

=cut

my $go = Getopt::Compact->new(
	name => 'svsh',
	modes => ['perp', 's6', 'runit'],
	struct => [
		[['d', 'basedir'], 'service directory (directory on which the supervisor was started)', '=s'],
		[['b', 'bindir'], 'directory where the supervisor is installed (e.g. /usr/sbin)', ':s'],
		[['c', 'collapse'], 'collapse numbered services into one line']
	]
);
my $opts = $go->opts;

my $class = 'Svsh::' . ( delete $opts->{perp}  ? 'Perp'  :
				 delete $opts->{s6}    ? 'S6'    :
				 delete $opts->{runit} ? 'Runit' :
				 confess 'What supervisor are you using?' );

eval "require $class";

confess $@
	if $@;

_check_basedir($opts->{basedir});

my $svsh = $class->new(%$opts);

my $term = Term::ShellUI->new(
	commands => {
		status => {
			desc => 'Lists all processes and their statuses',
			method => sub {
				my %statuses = %{$svsh->status(@_)};

				if ($svsh->collapse) {
					my $collapsed = {};
					foreach my $sv (keys %statuses) {
						next unless $sv =~ m/-\d+$/;
						$collapsed->{$`} ||= [];
						push(@{$collapsed->{$`}}, delete $statuses{$sv});
					}
					foreach my $sv (keys %$collapsed) {
						my $status_counters = {};
						my $duration = 0;
						foreach my $proc (@{$collapsed->{$sv}}) {
							$status_counters->{$proc->{status}} += 1;
							$duration = $proc->{duration}
								if $proc->{duration} > $duration;
						}
						$statuses{$sv} = {
							status => join(', ', map($status_counters->{$_}.' '.$_, sort(keys(%$status_counters)))),
							pid => '-',
							duration => $duration
						};
					}
				}

				print BOLD BLACK ON_WHITE
					join(' | ',
						sprintf('%16s', 'process'),
						sprintf('%10s',  'status'),
						sprintf('%8s', 'duration'),
						sprintf('%5s',      'pid')
					), ' ', RESET, "\n";
				foreach (sort keys %statuses) {
					my $s = $statuses{$_};
					my $color = $s->{status} =~ m/^(\d+ )?up$/ ? GREEN :
							$s->{status} eq 'resetting' ? YELLOW : RED;
					print BOLD sprintf('%16s', $_), RESET, ' | ',
						$color, sprintf('%10s', $s->{status}), RESET, ' | ',
						sprintf('%8s', $s->{duration}.'s'), ' | ',
						sprintf('%5s', $s->{pid}), " \n";
				}
				print "\n";
			},
			doc => "\nUsage: status\n\nLists all services in the service directory and their statuses, including uptime (or downtime) and PIDs.\n\nIn Perp, status can be 'up', 'down' (an expected down, such as the process being manually stopped),\n'resetting', 'disabled' or 'backoff' (meaning the process should be up, but fails to load).\n\nIn S6, only 'up' and 'down' are provided.\n"
		},
		toggle => {
			desc => 'Toggle svsh switches (e.g. collapse)',
			minargs => 1,
			maxargs => 1,
			method => sub {
				foreach (@{$_[1]->{args}}) {
					next unless $svsh->can($_);
					$svsh->$_($svsh->$_ ? 0 : 1);
				}
				$_[0]->process_a_cmd('status');
			}
		},
		start => {
			desc => 'Starts a list of processes',
			minargs => 1,
			method => sub { print $svsh->start(@_) }
		},
		stop => {
			desc => 'Stops a list of running processes',
			minargs => 1,
			method => sub { print $svsh->stop(@_) }
		},
		restart => {
			desc => 'Restarts a list of processes',
			minargs => 1,
			method => sub { print $svsh->restart(@_) }
		},
		signal => {
			desc => 'Sends a signal to a list of processes',
			minargs => 2,
			method => sub { print $svsh->signal(@_) }
		},
		rescan => {
			desc => 'Rescans the service directory to look for new/removed services',
			maxargs => 0,
			method => sub {
				if ($svsh->can('rescan')) {
					print $svsh->rescan;
				} else {
					print ref($svsh).' does not support the rescan command', "\n";
				}
			}
		},
		update => { alias => 'rescan' },
		fg => {
			desc => 'Move a process to the foreground',
			minargs => 1,
			maxargs => 1,
			method => sub { $svsh->fg(@_) }
		},
		terminate => {
			desc => 'Shut down the process supervisor (all processes will terminate)',
			method => sub {
				if ($svsh->can('terminate')) {
					$svsh->terminate();
					shift->process_a_cmd('quit');
				} else {
					print ref($svsh).' does not support the terminate command', "\n";
				}
			}
		},
		shutdown => { alias => 'terminate' },
		help => {
			desc => 'Print helpful information',
			args => sub { shift->help_args(undef, @_); },
			method => sub { shift->help_call(undef, @_); }
		},
		quit => {
			desc => 'Quit this program',
			maxargs => 0,
			method => sub { shift->exit_requested(1) }
		},
		exit => { alias => 'quit' }
	},
	prompt => 'svsh> '
);
$term->process_a_cmd('status')
	unless scalar @ARGV;
$term->run(@ARGV);

sub _check_basedir {
	my $basedir = shift;
	try {
		$basedir || die "Base directory not provided";
		-e $basedir && -d $basedir
			|| die "Base directory does not exist or is not a directory";

		return $basedir;
	} catch {
		print "ERROR: $_\n", $go->usage;
		exit 1;
	};
}
