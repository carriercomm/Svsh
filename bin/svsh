#!/usr/bin/env perl

# ABSTRACT: Process supervision shell for Perp and S6

use lib 'lib';
use warnings;
use strict;

use Carp;
use Getopt::Compact;
use Term::ShellUI;
use Try::Tiny;

my $go = Getopt::Compact->new(
	name => 'svsh',
	args => 'basedir',
	modes => ['perp', 's6'],
	struct => [
		[['b', 'bindir'], 'directory where the supervisor is installed (e.g. /usr/sbin)', ':s']
	]
);
my $opts = $go->opts;

my $class = 'Svsh::' . ( delete $opts->{perp} ? 'Perp' :
				 delete $opts->{s6}   ? 'S6'   :
				 confess 'What supervisor are you using?' );

eval "require $class";

confess $@
	if $@;

$opts->{basedir} = _check_basedir();

my $svsh = $class->new(%$opts);

my $term = Term::ShellUI->new(
	commands => {
		status => {
			desc => 'Lists all running processes',
			method => sub { $svsh->status }
		},
		start => {
			desc => 'Starts process',
			minargs => 1,
			method => sub { $svsh->start(@_) }
		},
		stop => {
			desc => 'Stops a running process',
			minargs => 1,
			method => sub { $svsh->stop(@_) }
		},
		enable => {
			desc => 'Start a process and enable auto-starting of it',
			minargs => 1,
			method => sub { $svsh->enable(@_) }
		},
		disable => {
			desc => 'Stops a process and disables auto-starting of it',
			minargs => 1,
			method => sub { $svsh->disable(@_) }
		},
		signal => {
			desc => 'Sends a signal to a process (or processes)',
			minargs => 1,
			method => sub { $svsh->signal(@_) }
		},
		fg => {
			desc => 'Move a process to the foreground',
			minargs => 1,
			maxargs => 1,
			method => sub { $svsh->fg(@_) }
		},
		terminate => {
			desc => 'Shut down the process supervisor (all processes will terminate)',
			method => sub { $svsh->terminate(); shift->process_a_cmd('quit'); }
		},
		shutdown => { alias => 'terminate' },
		quit => {
			desc => 'Quit this program',
			maxargs => 0,
			method => sub { shift->exit_requested(1) }
		},
		exit => { alias => 'quit' }
	},
	prompt => 'svsh> '
);
$term->process_a_cmd('status');
$term->run();

sub _check_basedir {
	try {
		my $basedir = $ARGV[0]
			|| die "Base directory not provided";
		-e $basedir && -d $basedir
			|| die "Base directory does not exist or is not a directory";

		return $basedir;
	} catch {
		print "ERROR: $_\n", $go->usage;
		exit 1;
	};
}
