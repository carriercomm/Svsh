#!/usr/bin/env perl

BEGIN {
	binmode STDOUT, ':encoding(utf8)';
}

# ABSTRACT: Process supervision shell for Perp and S6

use lib 'lib';
use warnings;
use strict;

use Carp;
use Getopt::Compact;
use Term::ANSIColor qw/:constants/;
use Term::ShellUI;
use Try::Tiny;

my $go = Getopt::Compact->new(
	name => 'svsh',
	modes => ['perp', 's6'],
	struct => [
		[['d', 'basedir'], 'service directory (directory on which the supervisor was started)', '=s'],
		[['b', 'bindir'], 'directory where the supervisor is installed (e.g. /usr/sbin)', ':s'],
		[['c', 'collapse'], 'collapse numbered services into one line']
	]
);
my $opts = $go->opts;

my $class = 'Svsh::' . ( delete $opts->{perp} ? 'Perp' :
				 delete $opts->{s6}   ? 'S6'   :
				 confess 'What supervisor are you using?' );

eval "require $class";

confess $@
	if $@;

_check_basedir($opts->{basedir});

my $svsh = $class->new(%$opts);

my $term = Term::ShellUI->new(
	commands => {
		status => {
			desc => 'Lists all processes and their statuses',
			method => sub {
				my %statuses = %{$svsh->status(@_)};

				if ($svsh->collapse) {
					my $collapsed = {};
					foreach my $sv (keys %statuses) {
						next unless $sv =~ m/-\d+$/;
						$collapsed->{$`} ||= [];
						push(@{$collapsed->{$`}}, delete $statuses{$sv});
					}
					foreach my $sv (keys %$collapsed) {
						my $status_counters = {};
						my $duration = 0;
						foreach my $proc (@{$collapsed->{$sv}}) {
							$status_counters->{$proc->{status}} += 1;
							$duration = $proc->{duration}
								if $proc->{duration} > $duration;
						}
						$statuses{$sv} = {
							status => join(', ', map($status_counters->{$_}.' '.$_, sort(keys(%$status_counters)))),
							pid => '-',
							duration => $duration
						};
					}
				}

				print BOLD BLACK ON_WHITE
					join(' | ',
						sprintf('%16s', 'process'),
						sprintf('%10s',  'status'),
						sprintf('%8s', 'duration'),
						sprintf('%5s',      'pid')
					), ' ', RESET, "\n";
				foreach (sort keys %statuses) {
					my $s = $statuses{$_};
					my $color = $s->{status} =~ m/^(\d+ )?up$/ ? GREEN :
							$s->{status} eq 'resetting' ? YELLOW : RED;
					print BOLD sprintf('%16s', $_), RESET, ' | ',
						$color, sprintf('%10s', $s->{status}), RESET, ' | ',
						sprintf('%8s', $s->{duration}.'s'), ' | ',
						sprintf('%5s', $s->{pid}), " \n";
				}
				print "\n";
			},
			doc => "\nUsage: status\n\nLists all services in the service directory and their statuses, including uptime (or downtime) and PIDs.\n\nIn Perp, status can be 'up', 'down' (an expected down, such as the process being manually stopped),\n'resetting', 'disabled' or 'backoff' (meaning the process should be up, but fails to load).\n\nIn S6, only 'up' and 'down' are provided.\n"
		},
		toggle => {
			desc => 'Toggle svsh switches (e.g. collapse)',
			minargs => 1,
			maxargs => 1,
			method => sub {
				foreach (@{$_[1]->{args}}) {
					next unless $svsh->can($_);
					$svsh->$_($svsh->$_ ? 0 : 1);
				}
				$_[0]->process_a_cmd('status');
			}
		},
		start => {
			desc => 'Starts a list of processes',
			minargs => 1,
			method => sub { print $svsh->start(@_) }
		},
		stop => {
			desc => 'Stops a list of running processes',
			minargs => 1,
			method => sub { print $svsh->stop(@_) }
		},
		restart => {
			desc => 'Restarts a list of processes',
			minargs => 1,
			method => sub { print $svsh->restart(@_) }
		},
		signal => {
			desc => 'Sends a signal to a list of processes',
			minargs => 2,
			method => sub { print $svsh->signal(@_) }
		},
		rescan => {
			desc => 'Rescans the service directory to look for new/removed services',
			maxargs => 0,
			method => sub { print $svsh->rescan }
		},
		update => { alias => 'rescan' },
		fg => {
			desc => 'Move a process to the foreground',
			minargs => 1,
			maxargs => 1,
			method => sub { $svsh->fg(@_) }
		},
		terminate => {
			desc => 'Shut down the process supervisor (all processes will terminate)',
			method => sub { $svsh->terminate(); shift->process_a_cmd('quit'); }
		},
		shutdown => { alias => 'terminate' },
		help => {
			desc => 'Print helpful information',
			args => sub { shift->help_args(undef, @_); },
			method => sub { shift->help_call(undef, @_); }
		},
		quit => {
			desc => 'Quit this program',
			maxargs => 0,
			method => sub { shift->exit_requested(1) }
		},
		exit => { alias => 'quit' }
	},
	prompt => 'svsh> '
);
$term->process_a_cmd('status')
	unless scalar @ARGV;
$term->run(@ARGV);

sub _check_basedir {
	my $basedir = shift;
	try {
		$basedir || die "Base directory not provided";
		-e $basedir && -d $basedir
			|| die "Base directory does not exist or is not a directory";

		return $basedir;
	} catch {
		print "ERROR: $_\n", $go->usage;
		exit 1;
	};
}
